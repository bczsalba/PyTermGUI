"""
Helper functions for Windows
"""

from msvcrt import getch as _getch, kbhit
from ctypes import windll, byref
from ctypes.wintypes import DWORD, HANDLE
from enum import IntEnum
from typing import Callable

from .helpers import export
from . import keys

kernel32 = windll.kernel32


class Handles(IntEnum):
    """Console Modes"""

    STD_INPUT_HANDLE: int = -10
    """Standard input (stdin) handle"""
    STD_OUTPUT_HANDLE: int = -11
    """Standard output (stdout) handle"""
    STD_ERROR_HANDLE: int = -12
    """Standard error (stderr) handle"""


class ReadConsoleModes(IntEnum):
    """Console Input Modes"""

    ENABLE_ECHO_INPUT: int = 0x0004
    """
    Characters read by the `ReadFile` or `ReadConsole` function are written to the active screen
    buffer as they are typed into the console.
    This mode can be used only if the `ENABLE_LINE_INPUT` mode is also enabled.
    """
    ENABLE_INSERT_MODE: int = 0x0020
    """
    When enabled, text entered in a console window will be inserted at the current cursor location
    and all text following that location will not be overwritten.
    When disabled, all following text will be overwritten.
    """
    ENABLE_LINE_INPUT: int = 0x0002
    """
    The `ReadFile` or `ReadConsole` function returns only when a carriage return character is read.
    If this mode is disabled, the functions return when one or more characters are available.
    """
    ENABLE_MOUSE_INPUT: int = 0x0010
    """
    If the mouse pointer is within the borders of the console window and the window has the
    keyboard focus, mouse events generated by mouse movement and button presses are placed in the
    input buffer.
    These events are discarded by `ReadFile` or `ReadConsole`, even when this mode is enabled.
    """
    ENABLE_PROCESSED_INPUT: int = 0x0001
    """
    `CTRL+C` is processed by the system and is not placed in the input buffer.
    If the input buffer is being read by `ReadFile` or `ReadConsole`, other control keys are
    processed by the system and are not returned in the `ReadFile` or `ReadConsole` buffer.
    If the `ENABLE_LINE_INPUT` mode is also enabled, backspace, carriage return, and line feed
    characters are handled by the system.
    """
    ENABLE_QUICK_EDIT_MODE: int = 0x0040
    """
    This flag enables the user to use the mouse to select and edit text.
    To enable this mode, use `ENABLE_QUICK_EDIT_MODE | ENABLE_EXTENDED_FLAGS`.
    To disable this mode, use `ENABLE_EXTENDED_FLAGS` without this flag.
    """
    ENABLE_WINDOW_INPUT: int = 0x0008
    """
    User interactions that change the size of the console screen buffer are reported in the
    console's input buffer.
    Information about these events can be read from the input buffer by applications using the
    `ReadConsoleInput` function, but not by those using `ReadFile` or `ReadConsole`.
    """
    ENABLE_VIRTUAL_TERMINAL_INPUT: int = 0x0200
    """
    Setting this flag directs the **Virtual Terminal** processing engine to convert user input
    received by the console window into **Console Virtual Terminal Sequences** that can be retrieved
    by a supporting application through `WriteFile` or `WriteConsole` functions.

    The typical usage of this flag is intended in conjunction with
    `ENABLE_VIRTUAL_TERMINAL_PROCESSING` on the output handle to connect to an application that
    communicates exclusively via virtual terminal sequences.
    """


def echo_on() -> None:
    """Turns on ECHO"""

    handle: HANDLE = kernel32.GetStdHandle(Handles.STD_INPUT_HANDLE)
    mode: DWORD = DWORD()

    if kernel32.GetConsoleMode(handle, byref(mode)):
        mode |= ReadConsoleModes.ENABLE_ECHO_INPUT
        kernel32.SetConsoleMode(handle, mode)


def echo_off() -> None:
    """Turns off ECHO"""

    handle: HANDLE = kernel32.GetStdHandle(Handles.STD_INPUT_HANDLE)
    mode: DWORD = DWORD()

    if kernel32.GetConsoleMode(handle, byref(mode)):
        mode &= ~ReadConsoleModes.ENABLE_ECHO_INPUT
        kernel32.SetConsoleMode(handle, mode)


def getch(echo: bool = False) -> str:
    """
    Gets a single unbuffered character from standard input.

    Args:
        echo (bool, optional): Print character on screen. Defaults to False.

    Returns:
        str: Single unbuffered character
    """


xlate_dict = {
    13: keys.ENTER,
    27: keys.ESC,
    15104: keys.F1,
    15360: keys.F2,
    15616: keys.F3,
    15872: keys.F4,
    16128: keys.F5,
    16384: keys.F6,
    16640: keys.F7,
    16896: keys.F8,
    17152: keys.F9,
    17408: keys.F10,
    22272: keys.F11,
    34528: keys.F12,
    7680: keys.ALT_A,
    # don't have table entries for...
    # CTRL_ALT_A, # Ctrl-Alt-A, etc.
    # CTRL_ALT_SUPR,
    # CTRL-F1
    21216: keys.INSERT,
    21472: keys.SUPR,  # keys.py uses SUPR, not DELETE
    18912: keys.PAGE_UP,
    20960: keys.PAGE_DOWN,
    18400: keys.HOME,
    20448: keys.END,
    18432: keys.UP,  # 72 * 256
    20480: keys.DOWN,  # 80 * 256
    19200: keys.LEFT,  # 75 * 256
    19712: keys.RIGHT,  # 77 * 256
}

@export
def getkey(getch_: Callable = _getch) -> str | None:
    """
    Get a single character on Windows. if an extended key is pressed, the Windows scan code is
    translated into a the unicode sequences

    Args:
        getch (Callable, optional): Getch function to use. Defaults to msvcrt.getch.

    Returns:
        str: Result
    """

    while True:
        if kbhit():
            char: bytes = getch_()
            char_ord: int = ord(char)
            if char_ord in (0, 224):
                temp: int = ord(getch_())
                res: int = char_ord + (temp * 256)
                return xlate_dict.get(res, None)
            return char.decode()
